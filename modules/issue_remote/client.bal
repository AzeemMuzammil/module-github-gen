// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/http;

# GitHub's v3 REST API.
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config =  {}, string serviceUrl = "https://api.github.com") returns error? {
        http:ClientConfiguration httpClientConfig = {httpVersion: config.httpVersion, timeout: config.timeout, forwarded: config.forwarded, poolConfig: config.poolConfig, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, validation: config.validation};
        do {
            if config.http1Settings is ClientHttp1Settings {
                ClientHttp1Settings settings = check config.http1Settings.ensureType(ClientHttp1Settings);
                httpClientConfig.http1Settings = {...settings};
            }
            if config.http2Settings is http:ClientHttp2Settings {
                httpClientConfig.http2Settings = check config.http2Settings.ensureType(http:ClientHttp2Settings);
            }
            if config.cache is http:CacheConfig {
                httpClientConfig.cache = check config.cache.ensureType(http:CacheConfig);
            }
            if config.responseLimits is http:ResponseLimitConfigs {
                httpClientConfig.responseLimits = check config.responseLimits.ensureType(http:ResponseLimitConfigs);
            }
            if config.secureSocket is http:ClientSecureSocket {
                httpClientConfig.secureSocket = check config.secureSocket.ensureType(http:ClientSecureSocket);
            }
            if config.proxy is http:ProxyConfig {
                httpClientConfig.proxy = check config.proxy.ensureType(http:ProxyConfig);
            }
        }
        http:Client httpEp = check new (serviceUrl, httpClientConfig);
        self.clientEp = httpEp;
        return;
    }
    # List issues assigned to the authenticated user
    #
    # + filter - Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
    # + state - Indicates the state of the issues to return.
    # + labels - A list of comma separated label names. Example: `bug,ui,@high`
    # + sort - What to sort results by.
    # + direction - The direction to sort the results by.
    # + since - Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    remote isolated function issuesList("assigned"|"created"|"mentioned"|"subscribed"|"repos"|"all" filter = "assigned", "open"|"closed"|"all" state = "open", string? labels = (), "created"|"updated"|"comments" sort = "created", "asc"|"desc" direction = "desc", string? since = (), boolean? collab = (), boolean? orgs = (), boolean? owned = (), boolean? pulls = (), int per_page = 30, int page = 1) returns Issue[]|error {
        string resourcePath = string `/issues`;
        map<anydata> queryParam = {"filter": filter, "state": state, "labels": labels, "sort": sort, "direction": direction, "since": since, "collab": collab, "orgs": orgs, "owned": owned, "pulls": pulls, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Issue[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List organization issues assigned to the authenticated user
    #
    # + org - The organization name. The name is not case sensitive.
    # + filter - Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
    # + state - Indicates the state of the issues to return.
    # + labels - A list of comma separated label names. Example: `bug,ui,@high`
    # + sort - What to sort results by.
    # + direction - The direction to sort the results by.
    # + since - Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    remote isolated function issuesListForOrg(string org, "assigned"|"created"|"mentioned"|"subscribed"|"repos"|"all" filter = "assigned", "open"|"closed"|"all" state = "open", string? labels = (), "created"|"updated"|"comments" sort = "created", "asc"|"desc" direction = "desc", string? since = (), int per_page = 30, int page = 1) returns Issue[]|error {
        string resourcePath = string `/orgs/${getEncodedUri(org)}/issues`;
        map<anydata> queryParam = {"filter": filter, "state": state, "labels": labels, "sort": sort, "direction": direction, "since": since, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Issue[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List assignees
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    remote isolated function issuesListAssignees(string owner, string repo, int per_page = 30, int page = 1) returns SimpleUser[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/assignees`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        SimpleUser[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Check if a user can be assigned
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned. 
    remote isolated function issuesCheckUserCanBeAssigned(string owner, string repo, string assignee) returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/assignees/${getEncodedUri(assignee)}`;
        http:Response response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List repository issues
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + milestone - If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*` is passed, issues with any milestone are accepted. If the string `none` is passed, issues without milestones are returned.
    # + state - Indicates the state of the issues to return.
    # + assignee - Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues assigned to any user.
    # + creator - The user that created the issue.
    # + mentioned - A user that's mentioned in the issue.
    # + labels - A list of comma separated label names. Example: `bug,ui,@high`
    # + sort - What to sort results by.
    # + direction - The direction to sort the results by.
    # + since - Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    remote isolated function issuesListForRepo(string owner, string repo, string? milestone = (), "open"|"closed"|"all" state = "open", string? assignee = (), string? creator = (), string? mentioned = (), string? labels = (), "created"|"updated"|"comments" sort = "created", "asc"|"desc" direction = "desc", string? since = (), int per_page = 30, int page = 1) returns Issue[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues`;
        map<anydata> queryParam = {"milestone": milestone, "state": state, "assignee": assignee, "creator": creator, "mentioned": mentioned, "labels": labels, "sort": sort, "direction": direction, "since": since, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Issue[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create an issue
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    remote isolated function issuesCreate(string owner, string repo, Repo_issues_body payload) returns Issue|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Issue response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # List issue comments for a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + sort - The property to sort the results by.
    # + direction - Either `asc` or `desc`. Ignored without the `sort` parameter.
    # + since - Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    remote isolated function issuesListCommentsForRepo(string owner, string repo, "created"|"updated" sort = "created", "asc"|"desc"? direction = (), string? since = (), int per_page = 30, int page = 1) returns IssueComment[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/comments`;
        map<anydata> queryParam = {"sort": sort, "direction": direction, "since": since, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        IssueComment[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get an issue comment
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + comment_id - The unique identifier of the comment.
    # + return - Response 
    remote isolated function issuesGetComment(string owner, string repo, int comment_id) returns IssueComment|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/comments/${getEncodedUri(comment_id)}`;
        IssueComment response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Delete an issue comment
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + comment_id - The unique identifier of the comment.
    # + return - Response 
    remote isolated function issuesDeleteComment(string owner, string repo, int comment_id) returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/comments/${getEncodedUri(comment_id)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Update an issue comment
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + comment_id - The unique identifier of the comment.
    # + return - Response 
    remote isolated function issuesUpdateComment(string owner, string repo, int comment_id, Comments_comment_id_body_2 payload) returns IssueComment|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/comments/${getEncodedUri(comment_id)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        IssueComment response = check self.clientEp->patch(resourcePath, request);
        return response;
    }
    # List issue events for a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    remote isolated function issuesListEventsForRepo(string owner, string repo, int per_page = 30, int page = 1) returns IssueEvent[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/events`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        IssueEvent[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get an issue event
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    remote isolated function issuesGetEvent(string owner, string repo, int event_id) returns IssueEvent|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/events/${getEncodedUri(event_id)}`;
        IssueEvent response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get an issue
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + issue_number - The number that identifies the issue.
    # + return - Response 
    remote isolated function issuesGet(string owner, string repo, int issue_number) returns Issue|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/${getEncodedUri(issue_number)}`;
        Issue response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Update an issue
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + issue_number - The number that identifies the issue.
    # + return - Response 
    remote isolated function issuesUpdate(string owner, string repo, int issue_number, Issues_issue_number_body payload) returns Issue|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/${getEncodedUri(issue_number)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Issue response = check self.clientEp->patch(resourcePath, request);
        return response;
    }
    # Add assignees to an issue
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + issue_number - The number that identifies the issue.
    # + return - Response 
    remote isolated function issuesAddAssignees(string owner, string repo, int issue_number, Issue_number_assignees_body payload) returns Issue|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/${getEncodedUri(issue_number)}/assignees`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Issue response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Remove assignees from an issue
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + issue_number - The number that identifies the issue.
    # + return - Response 
    remote isolated function issuesRemoveAssignees(string owner, string repo, int issue_number, Issue_number_assignees_body_1 payload) returns Issue|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/${getEncodedUri(issue_number)}/assignees`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Issue response = check self.clientEp->delete(resourcePath, request);
        return response;
    }
    # Check if a user can be assigned to a issue
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + issue_number - The number that identifies the issue.
    # + return - Response if `assignee` can be assigned to `issue_number` 
    remote isolated function issuesCheckUserCanBeAssignedToIssue(string owner, string repo, int issue_number, string assignee) returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/${getEncodedUri(issue_number)}/assignees/${getEncodedUri(assignee)}`;
        http:Response response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List issue comments
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + issue_number - The number that identifies the issue.
    # + since - Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    remote isolated function issuesListComments(string owner, string repo, int issue_number, string? since = (), int per_page = 30, int page = 1) returns IssueComment[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/${getEncodedUri(issue_number)}/comments`;
        map<anydata> queryParam = {"since": since, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        IssueComment[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create an issue comment
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + issue_number - The number that identifies the issue.
    # + return - Response 
    remote isolated function issuesCreateComment(string owner, string repo, int issue_number, Issue_number_comments_body payload) returns IssueComment|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/${getEncodedUri(issue_number)}/comments`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        IssueComment response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # List issue events
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + issue_number - The number that identifies the issue.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    remote isolated function issuesListEvents(string owner, string repo, int issue_number, int per_page = 30, int page = 1) returns IssueEventForIssue[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/${getEncodedUri(issue_number)}/events`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        IssueEventForIssue[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List labels for an issue
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + issue_number - The number that identifies the issue.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    remote isolated function issuesListLabelsOnIssue(string owner, string repo, int issue_number, int per_page = 30, int page = 1) returns Label[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/${getEncodedUri(issue_number)}/labels`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Label[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Set labels for an issue
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + issue_number - The number that identifies the issue.
    # + return - Response 
    remote isolated function issuesSetLabels(string owner, string repo, int issue_number, Issue_number_labels_body payload) returns Label[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/${getEncodedUri(issue_number)}/labels`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Label[] response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Add labels to an issue
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + issue_number - The number that identifies the issue.
    # + return - Response 
    remote isolated function issuesAddLabels(string owner, string repo, int issue_number, Issue_number_labels_body_1 payload) returns Label[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/${getEncodedUri(issue_number)}/labels`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Label[] response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Remove all labels from an issue
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + issue_number - The number that identifies the issue.
    # + return - Response 
    remote isolated function issuesRemoveAllLabels(string owner, string repo, int issue_number) returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/${getEncodedUri(issue_number)}/labels`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Remove a label from an issue
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + issue_number - The number that identifies the issue.
    # + return - Response 
    remote isolated function issuesRemoveLabel(string owner, string repo, int issue_number, string name) returns Label[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/${getEncodedUri(issue_number)}/labels/${getEncodedUri(name)}`;
        Label[] response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Lock an issue
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + issue_number - The number that identifies the issue.
    # + return - Response 
    remote isolated function issuesLock(string owner, string repo, int issue_number, Issue_number_lock_body payload) returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/${getEncodedUri(issue_number)}/lock`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Unlock an issue
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + issue_number - The number that identifies the issue.
    # + return - Response 
    remote isolated function issuesUnlock(string owner, string repo, int issue_number) returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/${getEncodedUri(issue_number)}/lock`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # List timeline events for an issue
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + issue_number - The number that identifies the issue.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    remote isolated function issuesListEventsForTimeline(string owner, string repo, int issue_number, int per_page = 30, int page = 1) returns TimelineIssueEvents[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/issues/${getEncodedUri(issue_number)}/timeline`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        TimelineIssueEvents[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List labels for a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    remote isolated function issuesListLabelsForRepo(string owner, string repo, int per_page = 30, int page = 1) returns Label[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/labels`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Label[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a label
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    remote isolated function issuesCreateLabel(string owner, string repo, Repo_labels_body payload) returns Label|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/labels`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Label response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Get a label
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    remote isolated function issuesGetLabel(string owner, string repo, string name) returns Label|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/labels/${getEncodedUri(name)}`;
        Label response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Delete a label
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    remote isolated function issuesDeleteLabel(string owner, string repo, string name) returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/labels/${getEncodedUri(name)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Update a label
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    remote isolated function issuesUpdateLabel(string owner, string repo, string name, Labels_name_body payload) returns Label|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/labels/${getEncodedUri(name)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Label response = check self.clientEp->patch(resourcePath, request);
        return response;
    }
    # List milestones
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + state - The state of the milestone. Either `open`, `closed`, or `all`.
    # + sort - What to sort results by. Either `due_on` or `completeness`.
    # + direction - The direction of the sort. Either `asc` or `desc`.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    remote isolated function issuesListMilestones(string owner, string repo, "open"|"closed"|"all" state = "open", "due_on"|"completeness" sort = "due_on", "asc"|"desc" direction = "asc", int per_page = 30, int page = 1) returns Milestone[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/milestones`;
        map<anydata> queryParam = {"state": state, "sort": sort, "direction": direction, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Milestone[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a milestone
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    remote isolated function issuesCreateMilestone(string owner, string repo, Repo_milestones_body payload) returns Milestone|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/milestones`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Milestone response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Get a milestone
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + milestone_number - The number that identifies the milestone.
    # + return - Response 
    remote isolated function issuesGetMilestone(string owner, string repo, int milestone_number) returns Milestone|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/milestones/${getEncodedUri(milestone_number)}`;
        Milestone response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Delete a milestone
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + milestone_number - The number that identifies the milestone.
    # + return - Response 
    remote isolated function issuesDeleteMilestone(string owner, string repo, int milestone_number) returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/milestones/${getEncodedUri(milestone_number)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Update a milestone
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + milestone_number - The number that identifies the milestone.
    # + return - Response 
    remote isolated function issuesUpdateMilestone(string owner, string repo, int milestone_number, Milestones_milestone_number_body payload) returns Milestone|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/milestones/${getEncodedUri(milestone_number)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Milestone response = check self.clientEp->patch(resourcePath, request);
        return response;
    }
    # List labels for issues in a milestone
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + milestone_number - The number that identifies the milestone.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    remote isolated function issuesListLabelsForMilestone(string owner, string repo, int milestone_number, int per_page = 30, int page = 1) returns Label[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/milestones/${getEncodedUri(milestone_number)}/labels`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Label[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List user account issues assigned to the authenticated user
    #
    # + filter - Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
    # + state - Indicates the state of the issues to return.
    # + labels - A list of comma separated label names. Example: `bug,ui,@high`
    # + sort - What to sort results by.
    # + direction - The direction to sort the results by.
    # + since - Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    remote isolated function issuesListForAuthenticatedUser("assigned"|"created"|"mentioned"|"subscribed"|"repos"|"all" filter = "assigned", "open"|"closed"|"all" state = "open", string? labels = (), "created"|"updated"|"comments" sort = "created", "asc"|"desc" direction = "desc", string? since = (), int per_page = 30, int page = 1) returns Issue[]|error {
        string resourcePath = string `/user/issues`;
        map<anydata> queryParam = {"filter": filter, "state": state, "labels": labels, "sort": sort, "direction": direction, "since": since, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Issue[] response = check self.clientEp->get(resourcePath);
        return response;
    }
}
