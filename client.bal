// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/http;

# GitHub's v3 REST API.
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config =  {}, string serviceUrl = "https://api.github.com") returns error? {
        http:ClientConfiguration httpClientConfig = {httpVersion: config.httpVersion, timeout: config.timeout, forwarded: config.forwarded, poolConfig: config.poolConfig, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, validation: config.validation};
        do {
            if config.http1Settings is ClientHttp1Settings {
                ClientHttp1Settings settings = check config.http1Settings.ensureType(ClientHttp1Settings);
                httpClientConfig.http1Settings = {...settings};
            }
            if config.http2Settings is http:ClientHttp2Settings {
                httpClientConfig.http2Settings = check config.http2Settings.ensureType(http:ClientHttp2Settings);
            }
            if config.cache is http:CacheConfig {
                httpClientConfig.cache = check config.cache.ensureType(http:CacheConfig);
            }
            if config.responseLimits is http:ResponseLimitConfigs {
                httpClientConfig.responseLimits = check config.responseLimits.ensureType(http:ResponseLimitConfigs);
            }
            if config.secureSocket is http:ClientSecureSocket {
                httpClientConfig.secureSocket = check config.secureSocket.ensureType(http:ClientSecureSocket);
            }
            if config.proxy is http:ProxyConfig {
                httpClientConfig.proxy = check config.proxy.ensureType(http:ProxyConfig);
            }
        }
        http:Client httpEp = check new (serviceUrl, httpClientConfig);
        self.clientEp = httpEp;
        return;
    }
    # List organization repositories
    #
    # + org - The organization name. The name is not case sensitive.
    # + 'type - Specifies the types of repositories you want returned.
    # + sort - The property to sort the results by.
    # + direction - The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get orgs/[string org]/repos("all"|"public"|"private"|"forks"|"sources"|"member" 'type = "all", "created"|"updated"|"pushed"|"full_name" sort = "created", "asc"|"desc"? direction = (), int per_page = 30, int page = 1) returns MinimalRepository[]|error {
        string resourcePath = string `/orgs/${getEncodedUri(org)}/repos`;
        map<anydata> queryParam = {"type": 'type, "sort": sort, "direction": direction, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        MinimalRepository[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create an organization repository
    #
    # + org - The organization name. The name is not case sensitive.
    # + return - Response 
    resource isolated function post orgs/[string org]/repos(Org_repos_body payload) returns Repository|error {
        string resourcePath = string `/orgs/${getEncodedUri(org)}/repos`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Repository response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Get all organization repository rulesets
    #
    # + org - The organization name. The name is not case sensitive.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get orgs/[string org]/rulesets(int per_page = 30, int page = 1) returns RepositoryRuleset[]|error {
        string resourcePath = string `/orgs/${getEncodedUri(org)}/rulesets`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        RepositoryRuleset[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create an organization repository ruleset
    #
    # + org - The organization name. The name is not case sensitive.
    # + payload - Request body
    # + return - Response 
    resource isolated function post orgs/[string org]/rulesets(Org_rulesets_body payload) returns RepositoryRuleset|error {
        string resourcePath = string `/orgs/${getEncodedUri(org)}/rulesets`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        RepositoryRuleset response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # List organization rule suites
    #
    # + org - The organization name. The name is not case sensitive.
    # + repository_name - The name of the repository to filter on. When specified, only rule evaluations from this repository will be returned.
    # + time_period - The time period to filter by.
    # For example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for insights that occurred in the past 7 days (168 hours).
    # + actor_name - The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.
    # + rule_suite_result - The rule results to filter on. When specified, only suites with this result will be returned.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get orgs/[string org]/rulesets/rule\-suites(int? repository_name = (), "hour"|"day"|"week"|"month" time_period = "day", string? actor_name = (), "pass"|"fail"|"bypass"|"all" rule_suite_result = "all", int per_page = 30, int page = 1) returns RuleSuites|error {
        string resourcePath = string `/orgs/${getEncodedUri(org)}/rulesets/rule-suites`;
        map<anydata> queryParam = {"repository_name": repository_name, "time_period": time_period, "actor_name": actor_name, "rule_suite_result": rule_suite_result, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        RuleSuites response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get an organization rule suite
    #
    # + org - The organization name. The name is not case sensitive.
    # + rule_suite_id - The unique identifier of the rule suite result.
    # To get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)
    # for repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites)
    # for organizations.
    # + return - Response 
    resource isolated function get orgs/[string org]/rulesets/rule\-suites/[int rule_suite_id]() returns RuleSuite|error {
        string resourcePath = string `/orgs/${getEncodedUri(org)}/rulesets/rule-suites/${getEncodedUri(rule_suite_id)}`;
        RuleSuite response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get an organization repository ruleset
    #
    # + org - The organization name. The name is not case sensitive.
    # + ruleset_id - The ID of the ruleset.
    # + return - Response 
    resource isolated function get orgs/[string org]/rulesets/[int ruleset_id]() returns RepositoryRuleset|error {
        string resourcePath = string `/orgs/${getEncodedUri(org)}/rulesets/${getEncodedUri(ruleset_id)}`;
        RepositoryRuleset response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Update an organization repository ruleset
    #
    # + org - The organization name. The name is not case sensitive.
    # + ruleset_id - The ID of the ruleset.
    # + payload - Request body
    # + return - Response 
    resource isolated function put orgs/[string org]/rulesets/[int ruleset_id](Rulesets_ruleset_id_body payload) returns RepositoryRuleset|error {
        string resourcePath = string `/orgs/${getEncodedUri(org)}/rulesets/${getEncodedUri(ruleset_id)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        RepositoryRuleset response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Delete an organization repository ruleset
    #
    # + org - The organization name. The name is not case sensitive.
    # + ruleset_id - The ID of the ruleset.
    # + return - Response 
    resource isolated function delete orgs/[string org]/rulesets/[int ruleset_id]() returns http:Response|error {
        string resourcePath = string `/orgs/${getEncodedUri(org)}/rulesets/${getEncodedUri(ruleset_id)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Get a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]() returns FullRepository|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}`;
        FullRepository response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Delete a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Update a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function patch repos/[string owner]/[string repo](Owner_repo_body_1 payload) returns FullRepository|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        FullRepository response = check self.clientEp->patch(resourcePath, request);
        return response;
    }
    # List repository activities
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + direction - The direction to sort the results by.
    # + per_page - The number of results per page (max 100).
    # + before - A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor.
    # + after - A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor.
    # + ref - The Git reference for the activities you want to list.
    # The `ref` for a branch can be formatted either as `refs/heads/BRANCH_NAME` or `BRANCH_NAME`, where `BRANCH_NAME` is the name of your branch.
    # + actor - The GitHub username to use to filter by the actor who performed the activity.
    # + time_period - The time period to filter by.
    # For example, `day` will filter for activity that occurred in the past 24 hours, and `week` will filter for activity that occurred in the past 7 days (168 hours).
    # + activity_type - The activity type to filter by.
    # For example, you can choose to filter by "force_push", to see all force pushes to the repository.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/activity("asc"|"desc" direction = "desc", int per_page = 30, string? before = (), string? after = (), string? ref = (), string? actor = (), "day"|"week"|"month"|"quarter"|"year"? time_period = (), "push"|"force_push"|"branch_creation"|"branch_deletion"|"pr_merge"|"merge_queue_merge"? activity_type = ()) returns Activity[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/activity`;
        map<anydata> queryParam = {"direction": direction, "per_page": per_page, "before": before, "after": after, "ref": ref, "actor": actor, "time_period": time_period, "activity_type": activity_type};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Activity[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List all autolinks of a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/autolinks(int page = 1) returns Autolink[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/autolinks`;
        map<anydata> queryParam = {"page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Autolink[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create an autolink reference for a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - response 
    resource isolated function post repos/[string owner]/[string repo]/autolinks(Repo_autolinks_body payload) returns Autolink|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/autolinks`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Autolink response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Get an autolink reference of a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + autolink_id - The unique identifier of the autolink.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/autolinks/[int autolink_id]() returns Autolink|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/autolinks/${getEncodedUri(autolink_id)}`;
        Autolink response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Delete an autolink reference from a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + autolink_id - The unique identifier of the autolink.
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/autolinks/[int autolink_id]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/autolinks/${getEncodedUri(autolink_id)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Check if automated security fixes are enabled for a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response if dependabot is enabled 
    resource isolated function get repos/[string owner]/[string repo]/automated\-security\-fixes() returns CheckAutomatedSecurityFixes|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/automated-security-fixes`;
        CheckAutomatedSecurityFixes response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Enable automated security fixes
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function put repos/[string owner]/[string repo]/automated\-security\-fixes() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/automated-security-fixes`;
        http:Request request = new;
        http:Response response = check self.clientEp-> put(resourcePath, request);
        return response;
    }
    # Disable automated security fixes
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/automated\-security\-fixes() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/automated-security-fixes`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # List branches
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + protected - Setting to `true` returns only protected branches. When set to `false`, only unprotected branches are returned. Omitting this parameter returns all branches.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/branches(boolean? protected = (), int per_page = 30, int page = 1) returns ShortBranch[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches`;
        map<anydata> queryParam = {"protected": protected, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        ShortBranch[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get a branch
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/branches/[string branch]() returns BranchWithProtection|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}`;
        BranchWithProtection response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get branch protection
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/branches/[string branch]/protection() returns BranchProtection|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection`;
        BranchProtection response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Update branch protection
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function put repos/[string owner]/[string repo]/branches/[string branch]/protection(Branch_protection_body payload) returns ProtectedBranch|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        ProtectedBranch response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Delete branch protection
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/branches/[string branch]/protection() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Get admin branch protection
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/branches/[string branch]/protection/enforce_admins() returns ProtectedBranchAdminEnforced|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/enforce_admins`;
        ProtectedBranchAdminEnforced response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Set admin branch protection
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/branches/[string branch]/protection/enforce_admins() returns ProtectedBranchAdminEnforced|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/enforce_admins`;
        http:Request request = new;
        ProtectedBranchAdminEnforced response = check self.clientEp-> post(resourcePath, request);
        return response;
    }
    # Delete admin branch protection
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/branches/[string branch]/protection/enforce_admins() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/enforce_admins`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Get pull request review protection
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/branches/[string branch]/protection/required_pull_request_reviews() returns ProtectedBranchPullRequestReview|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/required_pull_request_reviews`;
        ProtectedBranchPullRequestReview response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Delete pull request review protection
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/branches/[string branch]/protection/required_pull_request_reviews() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/required_pull_request_reviews`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Update pull request review protection
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function patch repos/[string owner]/[string repo]/branches/[string branch]/protection/required_pull_request_reviews(Protection_required_pull_request_reviews_body payload) returns ProtectedBranchPullRequestReview|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/required_pull_request_reviews`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        ProtectedBranchPullRequestReview response = check self.clientEp->patch(resourcePath, request);
        return response;
    }
    # Get commit signature protection
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/branches/[string branch]/protection/required_signatures() returns ProtectedBranchAdminEnforced|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/required_signatures`;
        ProtectedBranchAdminEnforced response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create commit signature protection
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/branches/[string branch]/protection/required_signatures() returns ProtectedBranchAdminEnforced|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/required_signatures`;
        http:Request request = new;
        ProtectedBranchAdminEnforced response = check self.clientEp-> post(resourcePath, request);
        return response;
    }
    # Delete commit signature protection
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/branches/[string branch]/protection/required_signatures() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/required_signatures`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Get status checks protection
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/branches/[string branch]/protection/required_status_checks() returns StatusCheckPolicy|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/required_status_checks`;
        StatusCheckPolicy response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Remove status check protection
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/branches/[string branch]/protection/required_status_checks() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/required_status_checks`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Update status check protection
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function patch repos/[string owner]/[string repo]/branches/[string branch]/protection/required_status_checks(Protection_required_status_checks_body payload) returns StatusCheckPolicy|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/required_status_checks`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        StatusCheckPolicy response = check self.clientEp->patch(resourcePath, request);
        return response;
    }
    # Get all status check contexts
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/branches/[string branch]/protection/required_status_checks/contexts() returns string[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/required_status_checks/contexts`;
        string[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Set status check contexts
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function put repos/[string owner]/[string repo]/branches/[string branch]/protection/required_status_checks/contexts(Required_status_checks_contexts_body payload) returns string[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/required_status_checks/contexts`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        string[] response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Add status check contexts
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/branches/[string branch]/protection/required_status_checks/contexts(Required_status_checks_contexts_body_1 payload) returns string[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/required_status_checks/contexts`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        string[] response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Remove status check contexts
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/branches/[string branch]/protection/required_status_checks/contexts(Required_status_checks_contexts_body_2 payload) returns string[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/required_status_checks/contexts`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        string[] response = check self.clientEp->delete(resourcePath, request);
        return response;
    }
    # Get access restrictions
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/branches/[string branch]/protection/restrictions() returns BranchRestrictionPolicy|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/restrictions`;
        BranchRestrictionPolicy response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Delete access restrictions
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/branches/[string branch]/protection/restrictions() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/restrictions`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Get apps with access to the protected branch
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/branches/[string branch]/protection/restrictions/apps() returns Integration[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/restrictions/apps`;
        Integration[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Set app access restrictions
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function put repos/[string owner]/[string repo]/branches/[string branch]/protection/restrictions/apps(Restrictions_apps_body payload) returns Integration[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/restrictions/apps`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Integration[] response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Add app access restrictions
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/branches/[string branch]/protection/restrictions/apps(Restrictions_apps_body_1 payload) returns Integration[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/restrictions/apps`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Integration[] response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Remove app access restrictions
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/branches/[string branch]/protection/restrictions/apps(Restrictions_apps_body_2 payload) returns Integration[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/restrictions/apps`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Integration[] response = check self.clientEp->delete(resourcePath, request);
        return response;
    }
    # Get teams with access to the protected branch
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/branches/[string branch]/protection/restrictions/teams() returns Team[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/restrictions/teams`;
        Team[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Set team access restrictions
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function put repos/[string owner]/[string repo]/branches/[string branch]/protection/restrictions/teams(Restrictions_teams_body payload) returns Team[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/restrictions/teams`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Team[] response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Add team access restrictions
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/branches/[string branch]/protection/restrictions/teams(Restrictions_teams_body_1 payload) returns Team[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/restrictions/teams`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Team[] response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Remove team access restrictions
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/branches/[string branch]/protection/restrictions/teams(Restrictions_teams_body_2 payload) returns Team[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/restrictions/teams`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Team[] response = check self.clientEp->delete(resourcePath, request);
        return response;
    }
    # Get users with access to the protected branch
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/branches/[string branch]/protection/restrictions/users() returns SimpleUser[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/restrictions/users`;
        SimpleUser[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Set user access restrictions
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function put repos/[string owner]/[string repo]/branches/[string branch]/protection/restrictions/users(Restrictions_users_body payload) returns SimpleUser[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/restrictions/users`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        SimpleUser[] response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Add user access restrictions
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/branches/[string branch]/protection/restrictions/users(Restrictions_users_body_1 payload) returns SimpleUser[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/restrictions/users`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        SimpleUser[] response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Remove user access restrictions
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/branches/[string branch]/protection/restrictions/users(Restrictions_users_body_2 payload) returns SimpleUser[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/protection/restrictions/users`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        SimpleUser[] response = check self.clientEp->delete(resourcePath, request);
        return response;
    }
    # Rename a branch
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/branches/[string branch]/rename(Branch_rename_body payload) returns BranchWithProtection|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/branches/${getEncodedUri(branch)}/rename`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        BranchWithProtection response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # List CODEOWNERS errors
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + ref - A branch, tag or commit name used to determine which version of the CODEOWNERS file to use. Default: the repository's default branch (e.g. `main`)
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/codeowners/errors(string? ref = ()) returns CodeownersErrors|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/codeowners/errors`;
        map<anydata> queryParam = {"ref": ref};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        CodeownersErrors response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List repository collaborators
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + affiliation - Filter collaborators returned by their affiliation. `outside` means all outside collaborators of an organization-owned repository. `direct` means all collaborators with permissions to an organization-owned repository, regardless of organization membership status. `all` means all collaborators the authenticated user can see.
    # + permission - Filter collaborators by the permissions they have on the repository. If not specified, all collaborators will be returned.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/collaborators("outside"|"direct"|"all" affiliation = "all", "pull"|"triage"|"push"|"maintain"|"admin"? permission = (), int per_page = 30, int page = 1) returns Collaborator[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/collaborators`;
        map<anydata> queryParam = {"affiliation": affiliation, "permission": permission, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Collaborator[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Check if a user is a repository collaborator
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + username - The handle for the GitHub user account.
    # + return - Response if user is a collaborator 
    resource isolated function get repos/[string owner]/[string repo]/collaborators/[string username]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/collaborators/${getEncodedUri(username)}`;
        http:Response response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Add a repository collaborator
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + username - The handle for the GitHub user account.
    # + return - Response when a new invitation is created 
    resource isolated function put repos/[string owner]/[string repo]/collaborators/[string username](Collaborators_username_body_1 payload) returns RepositoryInvitation|error? {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/collaborators/${getEncodedUri(username)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        RepositoryInvitation? response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Remove a repository collaborator
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + username - The handle for the GitHub user account.
    # + return - No Content when collaborator was removed from the repository. 
    resource isolated function delete repos/[string owner]/[string repo]/collaborators/[string username]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/collaborators/${getEncodedUri(username)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Get repository permissions for a user
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + username - The handle for the GitHub user account.
    # + return - if user has admin permissions 
    resource isolated function get repos/[string owner]/[string repo]/collaborators/[string username]/permission() returns RepositoryCollaboratorPermission|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/collaborators/${getEncodedUri(username)}/permission`;
        RepositoryCollaboratorPermission response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List commit comments for a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/comments(int per_page = 30, int page = 1) returns CommitComment[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/comments`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        CommitComment[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get a commit comment
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + comment_id - The unique identifier of the comment.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/comments/[int comment_id]() returns CommitComment|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/comments/${getEncodedUri(comment_id)}`;
        CommitComment response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Delete a commit comment
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + comment_id - The unique identifier of the comment.
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/comments/[int comment_id]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/comments/${getEncodedUri(comment_id)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Update a commit comment
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + comment_id - The unique identifier of the comment.
    # + return - Response 
    resource isolated function patch repos/[string owner]/[string repo]/comments/[int comment_id](Comments_comment_id_body_1 payload) returns CommitComment|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/comments/${getEncodedUri(comment_id)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        CommitComment response = check self.clientEp->patch(resourcePath, request);
        return response;
    }
    # List commits
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + sha - SHA or branch to start listing commits from. Default: the repositorys default branch (usually `main`).
    # + path - Only commits containing this file path will be returned.
    # + author - GitHub username or email address to use to filter by commit author.
    # + committer - GitHub username or email address to use to filter by commit committer.
    # + since - Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    # + until - Only commits before this date will be returned. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/commits(string? sha = (), string? path = (), string? author = (), string? committer = (), string? since = (), string? until = (), int per_page = 30, int page = 1) returns Commit[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/commits`;
        map<anydata> queryParam = {"sha": sha, "path": path, "author": author, "committer": committer, "since": since, "until": until, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Commit[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List branches for HEAD commit
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + commit_sha - The SHA of the commit.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/commits/[string commit_sha]/branches\-where\-head() returns BranchShort[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/commits/${getEncodedUri(commit_sha)}/branches-where-head`;
        BranchShort[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List commit comments
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + commit_sha - The SHA of the commit.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/commits/[string commit_sha]/comments(int per_page = 30, int page = 1) returns CommitComment[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/commits/${getEncodedUri(commit_sha)}/comments`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        CommitComment[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a commit comment
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + commit_sha - The SHA of the commit.
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/commits/[string commit_sha]/comments(Commit_sha_comments_body payload) returns CommitComment|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/commits/${getEncodedUri(commit_sha)}/comments`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        CommitComment response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # List pull requests associated with a commit
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + commit_sha - The SHA of the commit.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/commits/[string commit_sha]/pulls(int per_page = 30, int page = 1) returns PullRequestSimple[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/commits/${getEncodedUri(commit_sha)}/pulls`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        PullRequestSimple[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get a commit
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + page - Page number of the results to fetch.
    # + per_page - The number of results per page (max 100).
    # + ref - The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/commits/[string ref](int page = 1, int per_page = 30) returns Commit|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/commits/${getEncodedUri(ref)}`;
        map<anydata> queryParam = {"page": page, "per_page": per_page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Commit response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get the combined status for a specific reference
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + ref - The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/commits/[string ref]/status(int per_page = 30, int page = 1) returns CombinedCommitStatus|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/commits/${getEncodedUri(ref)}/status`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        CombinedCommitStatus response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List commit statuses for a reference
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + ref - The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/commits/[string ref]/statuses(int per_page = 30, int page = 1) returns Status[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/commits/${getEncodedUri(ref)}/statuses`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Status[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get community profile metrics
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/community/profile() returns CommunityProfile|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/community/profile`;
        CommunityProfile response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Compare two commits
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + page - Page number of the results to fetch.
    # + per_page - The number of results per page (max 100).
    # + basehead - The base branch and head branch to compare. This parameter expects the format `BASE...HEAD`. Both must be branch names in `repo`. To compare with a branch that exists in a different repository in the same network as `repo`, the `basehead` parameter expects the format `USERNAME:BASE...USERNAME:HEAD`.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/compare/[string basehead](int page = 1, int per_page = 30) returns CommitComparison|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/compare/${getEncodedUri(basehead)}`;
        map<anydata> queryParam = {"page": page, "per_page": per_page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        CommitComparison response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get repository content
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + path - path parameter
    # + ref - The name of the commit/branch/tag. Default: the repositorys default branch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/contents/[string path](string? ref = ()) returns ContentTree|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/contents/${getEncodedUri(path)}`;
        map<anydata> queryParam = {"ref": ref};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        ContentTree response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create or update file contents
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + path - path parameter
    # + return - Response 
    resource isolated function put repos/[string owner]/[string repo]/contents/[string path](Contents_path_body payload) returns FileCommit|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/contents/${getEncodedUri(path)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        FileCommit response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Delete a file
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + path - path parameter
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/contents/[string path](Contents_path_body_1 payload) returns FileCommit|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/contents/${getEncodedUri(path)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        FileCommit response = check self.clientEp->delete(resourcePath, request);
        return response;
    }
    # List repository contributors
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + anon - Set to `1` or `true` to include anonymous contributors in results.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - If repository contains content 
    resource isolated function get repos/[string owner]/[string repo]/contributors(string? anon = (), int per_page = 30, int page = 1) returns Contributor[]|error? {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/contributors`;
        map<anydata> queryParam = {"anon": anon, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Contributor[]? response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List deployments
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + sha - The SHA recorded at creation time.
    # + ref - The name of the ref. This can be a branch, tag, or SHA.
    # + task - The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).
    # + environment - The name of the environment that was deployed to (e.g., `staging` or `production`).
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/deployments(string sha = "none", string ref = "none", string task = "none", string environment = "none", int per_page = 30, int page = 1) returns Deployment[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/deployments`;
        map<anydata> queryParam = {"sha": sha, "ref": ref, "task": task, "environment": environment, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Deployment[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a deployment
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/deployments(Repo_deployments_body payload) returns Deployment|Inline_response_202|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/deployments`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Deployment|Inline_response_202 response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Get a deployment
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + deployment_id - deployment_id parameter
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/deployments/[int deployment_id]() returns Deployment|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/deployments/${getEncodedUri(deployment_id)}`;
        Deployment response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Delete a deployment
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + deployment_id - deployment_id parameter
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/deployments/[int deployment_id]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/deployments/${getEncodedUri(deployment_id)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # List deployment statuses
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + deployment_id - deployment_id parameter
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/deployments/[int deployment_id]/statuses(int per_page = 30, int page = 1) returns DeploymentStatus[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/deployments/${getEncodedUri(deployment_id)}/statuses`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        DeploymentStatus[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a deployment status
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + deployment_id - deployment_id parameter
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/deployments/[int deployment_id]/statuses(Deployment_id_statuses_body payload) returns DeploymentStatus|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/deployments/${getEncodedUri(deployment_id)}/statuses`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        DeploymentStatus response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Get a deployment status
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + deployment_id - deployment_id parameter
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/deployments/[int deployment_id]/statuses/[int status_id]() returns DeploymentStatus|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/deployments/${getEncodedUri(deployment_id)}/statuses/${getEncodedUri(status_id)}`;
        DeploymentStatus response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a repository dispatch event
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/dispatches(Repo_dispatches_body payload) returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/dispatches`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # List environments
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/environments(int per_page = 30, int page = 1) returns Inline_response_200_29|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/environments`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Inline_response_200_29 response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get an environment
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + environment_name - The name of the environment.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/environments/[string environment_name]() returns Environment|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/environments/${getEncodedUri(environment_name)}`;
        Environment response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create or update an environment
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + environment_name - The name of the environment.
    # + return - Response 
    resource isolated function put repos/[string owner]/[string repo]/environments/[string environment_name](Environments_environment_name_body payload) returns Environment|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/environments/${getEncodedUri(environment_name)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Environment response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Delete an environment
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + environment_name - The name of the environment.
    # + return - Default response 
    resource isolated function delete repos/[string owner]/[string repo]/environments/[string environment_name]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/environments/${getEncodedUri(environment_name)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # List deployment branch policies
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + environment_name - The name of the environment.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/environments/[string environment_name]/deployment\-branch\-policies(int per_page = 30, int page = 1) returns Inline_response_200_30|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/environments/${getEncodedUri(environment_name)}/deployment-branch-policies`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Inline_response_200_30 response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a deployment branch policy
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + environment_name - The name of the environment.
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/environments/[string environment_name]/deployment\-branch\-policies(DeploymentBranchPolicyNamePatternWithType payload) returns DeploymentBranchPolicy|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/environments/${getEncodedUri(environment_name)}/deployment-branch-policies`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        DeploymentBranchPolicy response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Get a deployment branch policy
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + environment_name - The name of the environment.
    # + branch_policy_id - The unique identifier of the branch policy.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/environments/[string environment_name]/deployment\-branch\-policies/[int branch_policy_id]() returns DeploymentBranchPolicy|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/environments/${getEncodedUri(environment_name)}/deployment-branch-policies/${getEncodedUri(branch_policy_id)}`;
        DeploymentBranchPolicy response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Update a deployment branch policy
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + environment_name - The name of the environment.
    # + branch_policy_id - The unique identifier of the branch policy.
    # + return - Response 
    resource isolated function put repos/[string owner]/[string repo]/environments/[string environment_name]/deployment\-branch\-policies/[int branch_policy_id](DeploymentBranchPolicyNamePattern payload) returns DeploymentBranchPolicy|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/environments/${getEncodedUri(environment_name)}/deployment-branch-policies/${getEncodedUri(branch_policy_id)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        DeploymentBranchPolicy response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Delete a deployment branch policy
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + environment_name - The name of the environment.
    # + branch_policy_id - The unique identifier of the branch policy.
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/environments/[string environment_name]/deployment\-branch\-policies/[int branch_policy_id]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/environments/${getEncodedUri(environment_name)}/deployment-branch-policies/${getEncodedUri(branch_policy_id)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Get all deployment protection rules for an environment
    #
    # + environment_name - The name of the environment.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + return - List of deployment protection rules 
    resource isolated function get repos/[string owner]/[string repo]/environments/[string environment_name]/deployment_protection_rules() returns Inline_response_200_31|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/environments/${getEncodedUri(environment_name)}/deployment_protection_rules`;
        Inline_response_200_31 response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a custom deployment protection rule on an environment
    #
    # + environment_name - The name of the environment.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + return - The enabled custom deployment protection rule 
    resource isolated function post repos/[string owner]/[string repo]/environments/[string environment_name]/deployment_protection_rules(Environment_name_deployment_protection_rules_body payload) returns DeploymentProtectionRule|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/environments/${getEncodedUri(environment_name)}/deployment_protection_rules`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        DeploymentProtectionRule response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # List custom deployment rule integrations available for an environment
    #
    # + environment_name - The name of the environment.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + page - Page number of the results to fetch.
    # + per_page - The number of results per page (max 100).
    # + return - A list of custom deployment rule integrations available for this environment. 
    resource isolated function get repos/[string owner]/[string repo]/environments/[string environment_name]/deployment_protection_rules/apps(int page = 1, int per_page = 30) returns Inline_response_200_32|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/environments/${getEncodedUri(environment_name)}/deployment_protection_rules/apps`;
        map<anydata> queryParam = {"page": page, "per_page": per_page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Inline_response_200_32 response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get a custom deployment protection rule
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + environment_name - The name of the environment.
    # + protection_rule_id - The unique identifier of the protection rule.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/environments/[string environment_name]/deployment_protection_rules/[int protection_rule_id]() returns DeploymentProtectionRule|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/environments/${getEncodedUri(environment_name)}/deployment_protection_rules/${getEncodedUri(protection_rule_id)}`;
        DeploymentProtectionRule response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Disable a custom protection rule for an environment
    #
    # + environment_name - The name of the environment.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + protection_rule_id - The unique identifier of the protection rule.
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/environments/[string environment_name]/deployment_protection_rules/[int protection_rule_id]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/environments/${getEncodedUri(environment_name)}/deployment_protection_rules/${getEncodedUri(protection_rule_id)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # List forks
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + sort - The sort order. `stargazers` will sort by star count.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/forks("newest"|"oldest"|"stargazers"|"watchers" sort = "newest", int per_page = 30, int page = 1) returns MinimalRepository[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/forks`;
        map<anydata> queryParam = {"sort": sort, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        MinimalRepository[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a fork
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/forks(Repo_forks_body payload) returns FullRepository|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/forks`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        FullRepository response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # List repository webhooks
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/hooks(int per_page = 30, int page = 1) returns Hook[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/hooks`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Hook[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a repository webhook
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/hooks(Repo_hooks_body payload) returns Hook|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/hooks`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Hook response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Get a repository webhook
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + hook_id - The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/hooks/[int hook_id]() returns Hook|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/hooks/${getEncodedUri(hook_id)}`;
        Hook response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Delete a repository webhook
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + hook_id - The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/hooks/[int hook_id]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/hooks/${getEncodedUri(hook_id)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Update a repository webhook
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + hook_id - The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
    # + return - Response 
    resource isolated function patch repos/[string owner]/[string repo]/hooks/[int hook_id](Hooks_hook_id_body_1 payload) returns Hook|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/hooks/${getEncodedUri(hook_id)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Hook response = check self.clientEp->patch(resourcePath, request);
        return response;
    }
    # Get a webhook configuration for a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + hook_id - The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/hooks/[int hook_id]/config() returns WebhookConfig|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/hooks/${getEncodedUri(hook_id)}/config`;
        WebhookConfig response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Update a webhook configuration for a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + hook_id - The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
    # + return - Response 
    resource isolated function patch repos/[string owner]/[string repo]/hooks/[int hook_id]/config(Hook_id_config_body_1 payload) returns WebhookConfig|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/hooks/${getEncodedUri(hook_id)}/config`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        WebhookConfig response = check self.clientEp->patch(resourcePath, request);
        return response;
    }
    # List deliveries for a repository webhook
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + hook_id - The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
    # + per_page - The number of results per page (max 100).
    # + cursor - Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/hooks/[int hook_id]/deliveries(int per_page = 30, string? cursor = (), boolean? redelivery = ()) returns HookDeliveryItem[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/hooks/${getEncodedUri(hook_id)}/deliveries`;
        map<anydata> queryParam = {"per_page": per_page, "cursor": cursor, "redelivery": redelivery};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        HookDeliveryItem[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get a delivery for a repository webhook
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + hook_id - The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/hooks/[int hook_id]/deliveries/[int delivery_id]() returns HookDelivery|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/hooks/${getEncodedUri(hook_id)}/deliveries/${getEncodedUri(delivery_id)}`;
        HookDelivery response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Redeliver a delivery for a repository webhook
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + hook_id - The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
    # + return - Accepted 
    resource isolated function post repos/[string owner]/[string repo]/hooks/[int hook_id]/deliveries/[int delivery_id]/attempts() returns json|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/hooks/${getEncodedUri(hook_id)}/deliveries/${getEncodedUri(delivery_id)}/attempts`;
        http:Request request = new;
        json response = check self.clientEp-> post(resourcePath, request);
        return response;
    }
    # Ping a repository webhook
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + hook_id - The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/hooks/[int hook_id]/pings() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/hooks/${getEncodedUri(hook_id)}/pings`;
        http:Request request = new;
        http:Response response = check self.clientEp-> post(resourcePath, request);
        return response;
    }
    # Test the push repository webhook
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + hook_id - The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/hooks/[int hook_id]/tests() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/hooks/${getEncodedUri(hook_id)}/tests`;
        http:Request request = new;
        http:Response response = check self.clientEp-> post(resourcePath, request);
        return response;
    }
    # List repository invitations
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/invitations(int per_page = 30, int page = 1) returns RepositoryInvitation[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/invitations`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        RepositoryInvitation[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Delete a repository invitation
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + invitation_id - The unique identifier of the invitation.
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/invitations/[int invitation_id]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/invitations/${getEncodedUri(invitation_id)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Update a repository invitation
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + invitation_id - The unique identifier of the invitation.
    # + return - Response 
    resource isolated function patch repos/[string owner]/[string repo]/invitations/[int invitation_id](Invitations_invitation_id_body payload) returns RepositoryInvitation|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/invitations/${getEncodedUri(invitation_id)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        RepositoryInvitation response = check self.clientEp->patch(resourcePath, request);
        return response;
    }
    # List deploy keys
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/keys(int per_page = 30, int page = 1) returns DeployKey[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/keys`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        DeployKey[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a deploy key
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/keys(Repo_keys_body payload) returns DeployKey|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/keys`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        DeployKey response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Get a deploy key
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + key_id - The unique identifier of the key.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/keys/[int key_id]() returns DeployKey|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/keys/${getEncodedUri(key_id)}`;
        DeployKey response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Delete a deploy key
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + key_id - The unique identifier of the key.
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/keys/[int key_id]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/keys/${getEncodedUri(key_id)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # List repository languages
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/languages() returns Language|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/languages`;
        Language response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Sync a fork branch with the upstream repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - The branch has been successfully synced with the upstream repository 
    resource isolated function post repos/[string owner]/[string repo]/merge\-upstream(Repo_mergeupstream_body payload) returns MergedUpstream|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/merge-upstream`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        MergedUpstream response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Merge a branch
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Successful Response (The resulting merge commit) 
    resource isolated function post repos/[string owner]/[string repo]/merges(Repo_merges_body payload) returns Commit|error? {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/merges`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Commit? response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Get a GitHub Pages site
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/pages() returns Page|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/pages`;
        Page response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Update information about a GitHub Pages site
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function put repos/[string owner]/[string repo]/pages(Repo_pages_body payload) returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/pages`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Create a GitHub Pages site
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/pages(Repo_pages_body_1 payload) returns Page|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/pages`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Page response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Delete a GitHub Pages site
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/pages() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/pages`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # List GitHub Pages builds
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/pages/builds(int per_page = 30, int page = 1) returns PageBuild[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/pages/builds`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        PageBuild[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Request a GitHub Pages build
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/pages/builds() returns PageBuildStatus|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/pages/builds`;
        http:Request request = new;
        PageBuildStatus response = check self.clientEp-> post(resourcePath, request);
        return response;
    }
    # Get latest Pages build
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/pages/builds/latest() returns PageBuild|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/pages/builds/latest`;
        PageBuild response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get GitHub Pages build
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/pages/builds/[int build_id]() returns PageBuild|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/pages/builds/${getEncodedUri(build_id)}`;
        PageBuild response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a GitHub Pages deployment
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/pages/deployment(Pages_deployment_body payload) returns PageDeployment|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/pages/deployment`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        PageDeployment response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Get a DNS health check for GitHub Pages
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/pages/health() returns PagesHealthCheck|EmptyObject|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/pages/health`;
        PagesHealthCheck|EmptyObject response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Enable private vulnerability reporting for a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - A header with no content is returned. 
    resource isolated function put repos/[string owner]/[string repo]/private\-vulnerability\-reporting() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/private-vulnerability-reporting`;
        http:Request request = new;
        http:Response response = check self.clientEp-> put(resourcePath, request);
        return response;
    }
    # Disable private vulnerability reporting for a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - A header with no content is returned. 
    resource isolated function delete repos/[string owner]/[string repo]/private\-vulnerability\-reporting() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/private-vulnerability-reporting`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Get a repository README
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + ref - The name of the commit/branch/tag. Default: the repositorys default branch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/readme(string? ref = ()) returns ContentFile|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/readme`;
        map<anydata> queryParam = {"ref": ref};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        ContentFile response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get a repository README for a directory
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + dir - The alternate path to look for a README file
    # + ref - The name of the commit/branch/tag. Default: the repositorys default branch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/readme/[string dir](string? ref = ()) returns ContentFile|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/readme/${getEncodedUri(dir)}`;
        map<anydata> queryParam = {"ref": ref};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        ContentFile response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List releases
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/releases(int per_page = 30, int page = 1) returns Release[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/releases`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Release[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a release
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/releases(Repo_releases_body payload) returns Release|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/releases`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Release response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Get a release asset
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + asset_id - The unique identifier of the asset.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/releases/assets/[int asset_id]() returns ReleaseAsset|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/releases/assets/${getEncodedUri(asset_id)}`;
        ReleaseAsset response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Delete a release asset
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + asset_id - The unique identifier of the asset.
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/releases/assets/[int asset_id]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/releases/assets/${getEncodedUri(asset_id)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Update a release asset
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + asset_id - The unique identifier of the asset.
    # + return - Response 
    resource isolated function patch repos/[string owner]/[string repo]/releases/assets/[int asset_id](Assets_asset_id_body payload) returns ReleaseAsset|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/releases/assets/${getEncodedUri(asset_id)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        ReleaseAsset response = check self.clientEp->patch(resourcePath, request);
        return response;
    }
    # Generate release notes content for a release
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Name and body of generated release notes 
    resource isolated function post repos/[string owner]/[string repo]/releases/generate\-notes(Releases_generatenotes_body payload) returns ReleaseNotesContent|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/releases/generate-notes`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        ReleaseNotesContent response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Get the latest release
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/releases/latest() returns Release|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/releases/latest`;
        Release response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get a release by tag name
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + tag - tag parameter
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/releases/tags/[string tag]() returns Release|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/releases/tags/${getEncodedUri(tag)}`;
        Release response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get a release
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + release_id - The unique identifier of the release.
    # + return - **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a [hypermedia resource](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia). 
    resource isolated function get repos/[string owner]/[string repo]/releases/[int release_id]() returns Release|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/releases/${getEncodedUri(release_id)}`;
        Release response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Delete a release
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + release_id - The unique identifier of the release.
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/releases/[int release_id]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/releases/${getEncodedUri(release_id)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Update a release
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + release_id - The unique identifier of the release.
    # + return - Response 
    resource isolated function patch repos/[string owner]/[string repo]/releases/[int release_id](Releases_release_id_body payload) returns Release|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/releases/${getEncodedUri(release_id)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Release response = check self.clientEp->patch(resourcePath, request);
        return response;
    }
    # List release assets
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + release_id - The unique identifier of the release.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/releases/[int release_id]/assets(int per_page = 30, int page = 1) returns ReleaseAsset[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/releases/${getEncodedUri(release_id)}/assets`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        ReleaseAsset[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Upload a release asset
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + release_id - The unique identifier of the release.
    # + return - Response for successful upload 
    resource isolated function post repos/[string owner]/[string repo]/releases/[int release_id]/assets(string name, byte[] payload, string? label = ()) returns ReleaseAsset|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/releases/${getEncodedUri(release_id)}/assets`;
        map<anydata> queryParam = {"name": name, "label": label};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        http:Request request = new;
        request.setPayload(payload, "application/octet-stream");
        ReleaseAsset response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Get rules for a branch
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + branch - The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/rules/branches/[string branch](int per_page = 30, int page = 1) returns RepositoryRuleDetailed[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/rules/branches/${getEncodedUri(branch)}`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        RepositoryRuleDetailed[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get all repository rulesets
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + includes_parents - Include rulesets configured at higher levels that apply to this repository
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/rulesets(int per_page = 30, int page = 1, boolean includes_parents = true) returns RepositoryRuleset[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/rulesets`;
        map<anydata> queryParam = {"per_page": per_page, "page": page, "includes_parents": includes_parents};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        RepositoryRuleset[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a repository ruleset
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + payload - Request body
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/rulesets(Repo_rulesets_body payload) returns RepositoryRuleset|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/rulesets`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        RepositoryRuleset response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # List repository rule suites
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + ref - The name of the ref. Cannot contain wildcard characters. When specified, only rule evaluations triggered for this ref will be returned.
    # + time_period - The time period to filter by.
    # For example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for insights that occurred in the past 7 days (168 hours).
    # + actor_name - The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.
    # + rule_suite_result - The rule results to filter on. When specified, only suites with this result will be returned.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/rulesets/rule\-suites(string? ref = (), "hour"|"day"|"week"|"month" time_period = "day", string? actor_name = (), "pass"|"fail"|"bypass"|"all" rule_suite_result = "all", int per_page = 30, int page = 1) returns RuleSuites|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/rulesets/rule-suites`;
        map<anydata> queryParam = {"ref": ref, "time_period": time_period, "actor_name": actor_name, "rule_suite_result": rule_suite_result, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        RuleSuites response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get a repository rule suite
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + rule_suite_id - The unique identifier of the rule suite result.
    # To get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)
    # for repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites)
    # for organizations.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/rulesets/rule\-suites/[int rule_suite_id]() returns RuleSuite|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/rulesets/rule-suites/${getEncodedUri(rule_suite_id)}`;
        RuleSuite response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get a repository ruleset
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + ruleset_id - The ID of the ruleset.
    # + includes_parents - Include rulesets configured at higher levels that apply to this repository
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/rulesets/[int ruleset_id](boolean includes_parents = true) returns RepositoryRuleset|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/rulesets/${getEncodedUri(ruleset_id)}`;
        map<anydata> queryParam = {"includes_parents": includes_parents};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        RepositoryRuleset response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Update a repository ruleset
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + ruleset_id - The ID of the ruleset.
    # + payload - Request body
    # + return - Response 
    resource isolated function put repos/[string owner]/[string repo]/rulesets/[int ruleset_id](Rulesets_ruleset_id_body_1 payload) returns RepositoryRuleset|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/rulesets/${getEncodedUri(ruleset_id)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        RepositoryRuleset response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Delete a repository ruleset
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + ruleset_id - The ID of the ruleset.
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/rulesets/[int ruleset_id]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/rulesets/${getEncodedUri(ruleset_id)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Get the weekly commit activity
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Returns a weekly aggregate of the number of additions and deletions pushed to a repository. 
    resource isolated function get repos/[string owner]/[string repo]/stats/code_frequency() returns json|CodeFrequencyStat[]|error? {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/stats/code_frequency`;
        json|CodeFrequencyStat[]? response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get the last year of commit activity
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/stats/commit_activity() returns json|CommitActivity[]|error? {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/stats/commit_activity`;
        json|CommitActivity[]? response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get all contributor commit activity
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/stats/contributors() returns json|ContributorActivity[]|error? {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/stats/contributors`;
        json|ContributorActivity[]? response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get the weekly commit count
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - The array order is oldest week (index 0) to most recent week. 
    resource isolated function get repos/[string owner]/[string repo]/stats/participation() returns ParticipationStats|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/stats/participation`;
        ParticipationStats response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get the hourly commit count for each day
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits. 
    resource isolated function get repos/[string owner]/[string repo]/stats/punch_card() returns CodeFrequencyStat[]|error? {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/stats/punch_card`;
        CodeFrequencyStat[]? response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a commit status
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/statuses/[string sha](Statuses_sha_body payload) returns Status|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/statuses/${getEncodedUri(sha)}`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Status response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # List repository tags
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/tags(int per_page = 30, int page = 1) returns Tag[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/tags`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Tag[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List tag protection states for a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/tags/protection() returns TagProtection[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/tags/protection`;
        TagProtection[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a tag protection state for a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/tags/protection(Tags_protection_body payload) returns TagProtection|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/tags/protection`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        TagProtection response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Delete a tag protection state for a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + tag_protection_id - The unique identifier of the tag protection.
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/tags/protection/[int tag_protection_id]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/tags/protection/${getEncodedUri(tag_protection_id)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Download a repository archive (tar)
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/tarball/[string ref]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/tarball/${getEncodedUri(ref)}`;
        http:Response response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List repository teams
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/teams(int per_page = 30, int page = 1) returns Team[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/teams`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Team[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get all repository topics
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + page - Page number of the results to fetch.
    # + per_page - The number of results per page (max 100).
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/topics(int page = 1, int per_page = 30) returns Topic|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/topics`;
        map<anydata> queryParam = {"page": page, "per_page": per_page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Topic response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Replace all repository topics
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function put repos/[string owner]/[string repo]/topics(Repo_topics_body payload) returns Topic|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/topics`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Topic response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Get repository clones
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + per - The time frame to display results for.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/traffic/clones("day"|"week" per = "day") returns CloneTraffic|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/traffic/clones`;
        map<anydata> queryParam = {"per": per};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        CloneTraffic response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get top referral paths
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/traffic/popular/paths() returns ContentTraffic[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/traffic/popular/paths`;
        ContentTraffic[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get top referral sources
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/traffic/popular/referrers() returns ReferrerTraffic[]|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/traffic/popular/referrers`;
        ReferrerTraffic[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Get page views
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + per - The time frame to display results for.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/traffic/views("day"|"week" per = "day") returns ViewTraffic|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/traffic/views`;
        map<anydata> queryParam = {"per": per};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        ViewTraffic response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Transfer a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function post repos/[string owner]/[string repo]/transfer(Repo_transfer_body payload) returns MinimalRepository|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/transfer`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        MinimalRepository response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Check if vulnerability alerts are enabled for a repository
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response if repository is enabled with vulnerability alerts 
    resource isolated function get repos/[string owner]/[string repo]/vulnerability\-alerts() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/vulnerability-alerts`;
        http:Response response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Enable vulnerability alerts
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function put repos/[string owner]/[string repo]/vulnerability\-alerts() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/vulnerability-alerts`;
        http:Request request = new;
        http:Response response = check self.clientEp-> put(resourcePath, request);
        return response;
    }
    # Disable vulnerability alerts
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function delete repos/[string owner]/[string repo]/vulnerability\-alerts() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/vulnerability-alerts`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Download a repository archive (zip)
    #
    # + owner - The account owner of the repository. The name is not case sensitive.
    # + repo - The name of the repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function get repos/[string owner]/[string repo]/zipball/[string ref]() returns http:Response|error {
        string resourcePath = string `/repos/${getEncodedUri(owner)}/${getEncodedUri(repo)}/zipball/${getEncodedUri(ref)}`;
        http:Response response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a repository using a template
    #
    # + template_owner - The account owner of the template repository. The name is not case sensitive.
    # + template_repo - The name of the template repository without the `.git` extension. The name is not case sensitive.
    # + return - Response 
    resource isolated function post repos/[string template_owner]/[string template_repo]/generate(Template_repo_generate_body payload) returns Repository|error {
        string resourcePath = string `/repos/${getEncodedUri(template_owner)}/${getEncodedUri(template_repo)}/generate`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Repository response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # List public repositories
    #
    # + since - A repository ID. Only return repositories with an ID greater than this ID.
    # + return - Response 
    resource isolated function get repositories(int? since = ()) returns MinimalRepository[]|error {
        string resourcePath = string `/repositories`;
        map<anydata> queryParam = {"since": since};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        MinimalRepository[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List repositories for the authenticated user
    #
    # + visibility - Limit results to repositories with the specified visibility.
    # + affiliation - Comma-separated list of values. Can include:  
    # * `owner`: Repositories that are owned by the authenticated user.  
    # * `collaborator`: Repositories that the user has been added to as a collaborator.  
    # * `organization_member`: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on.
    # + 'type - Limit results to repositories of the specified type. Will cause a `422` error if used in the same request as **visibility** or **affiliation**.
    # + sort - The property to sort the results by.
    # + direction - The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + since - Only show repositories updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    # + before - Only show repositories updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    # + return - Response 
    resource isolated function get user/repos("all"|"public"|"private" visibility = "all", string affiliation = "owner,collaborator,organization_member", "all"|"owner"|"public"|"private"|"member" 'type = "all", "created"|"updated"|"pushed"|"full_name" sort = "full_name", "asc"|"desc"? direction = (), int per_page = 30, int page = 1, string? since = (), string? before = ()) returns Repository[]|error {
        string resourcePath = string `/user/repos`;
        map<anydata> queryParam = {"visibility": visibility, "affiliation": affiliation, "type": 'type, "sort": sort, "direction": direction, "per_page": per_page, "page": page, "since": since, "before": before};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        Repository[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create a repository for the authenticated user
    #
    # + return - Response 
    resource isolated function post user/repos(User_repos_body payload) returns Repository|error {
        string resourcePath = string `/user/repos`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Repository response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # List repository invitations for the authenticated user
    #
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get user/repository_invitations(int per_page = 30, int page = 1) returns RepositoryInvitation[]|error {
        string resourcePath = string `/user/repository_invitations`;
        map<anydata> queryParam = {"per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        RepositoryInvitation[] response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Decline a repository invitation
    #
    # + invitation_id - The unique identifier of the invitation.
    # + return - Response 
    resource isolated function delete user/repository_invitations/[int invitation_id]() returns http:Response|error {
        string resourcePath = string `/user/repository_invitations/${getEncodedUri(invitation_id)}`;
        http:Response response = check self.clientEp-> delete(resourcePath);
        return response;
    }
    # Accept a repository invitation
    #
    # + invitation_id - The unique identifier of the invitation.
    # + return - Response 
    resource isolated function patch user/repository_invitations/[int invitation_id]() returns http:Response|error {
        string resourcePath = string `/user/repository_invitations/${getEncodedUri(invitation_id)}`;
        http:Request request = new;
        http:Response response = check self.clientEp-> patch(resourcePath, request);
        return response;
    }
    # List repositories for a user
    #
    # + username - The handle for the GitHub user account.
    # + 'type - Limit results to repositories of the specified type.
    # + sort - The property to sort the results by.
    # + direction - The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
    # + per_page - The number of results per page (max 100).
    # + page - Page number of the results to fetch.
    # + return - Response 
    resource isolated function get users/[string username]/repos("all"|"owner"|"member" 'type = "owner", "created"|"updated"|"pushed"|"full_name" sort = "full_name", "asc"|"desc"? direction = (), int per_page = 30, int page = 1) returns MinimalRepository[]|error {
        string resourcePath = string `/users/${getEncodedUri(username)}/repos`;
        map<anydata> queryParam = {"type": 'type, "sort": sort, "direction": direction, "per_page": per_page, "page": page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        MinimalRepository[] response = check self.clientEp->get(resourcePath);
        return response;
    }
}
